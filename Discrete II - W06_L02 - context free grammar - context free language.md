- FACT: context free grammars are inherently non-deterministic

---
#### Context free grammar
these are rules for one thing becoming another
1. A --> 0A1           *note: the first rule is implicitly the start*, or explicitly *S*
2. A --> B
3. B --> #

notice that these rules can count! as these rules can require a certain number of elements to be present in the language

> A --> 0A1 --> 00A11

every time we get a 0 or 1 also results in an A. this is a backwards way of counting but it still works. Because of this feature they are more powerful than regular languages. 
some important rules:
- only varibles allowed to left of arrows
- only *one* var on left of each arrow
- variables or terminals can be on the right

So how does the logic work?
1. write down the **start** symbol
2. **find** a variable thats written and a rule that has it as it's left-hand side
3. **replace** the variable with the right-hand side of the rule
4. **repeat** from step 2 until until your out of variables
Three things:
1. note only terminal symbols remain
2. the chain which is followed is called a derivation
3. it can also be represented as a parse tree
---
*context free grammars generate...*
### Context Free Languages
a **context-free-grammar** is a 4-tuple **G** = (V, $\sum$ , **R**, **S**) where
- **V** is a finite set called the **variables**
- $\sum$ is a finite set, disjoint from V, called **terminals**
- **R** is a finite set of **rules**, each rule allowing a variable to be rewritten as a string of variables and terminals, and
- **S** $\in$ **V** is the start variable
The **language** L(G) of a **grammar** is the set of strings which can be generated by that grammar
A **context free language** is a language that can be generated by a context free grammar
*some philosophy:* all computer programs have the same basic structure
1. given some input
2. process said input
3. enerate some output
---
**Another context free grammar example**
![[Pasted image 20220324211643.png]]
further example
![[Pasted image 20220324214235.png]]
---
**Notes on CFG Design**
Divide and conquer applies
- make simpler portions of the grammar, then make the grammar out of them
- simulate recursion by letting a variable generate itself, directly or indirectly
DFAs are easy to simulate with CFGs
- make a variable $V_i$ for each state $q_i$
- if $\delta(q_i,q_k) = a$, make a rule $V_i$ -> a$V_k$ 
- if $q_i$ is an accept state, make a rule $V_i$ -> $\varepsilon$ 
- make $v_0$ the starting variable
AGAIN
Because we have V -> aVb, ***you can count***

---
next lecture will cover *Ambiguity* and *Chomsky Normal Form*

